# warmup_project

## drive_square
### Description 
This node will cause the robot to drive forward for five seconds and then make a 90 degree turn. It will keep repeating this, effectively driving in a square path.

### Code Explanation
* `DriveSquare`: The pythonic object that is responsible for the **drive_square** behavior.
    * `DriveSquare.__init__()`: constructor for a `DriveSquare`. In addition to creating the object, this function initializes the ROS node, a `Twist` message for the node to use, and the `Twist` publisher. 
    * `DriveSquare.run()`: This starts the robot's movement. The function contains a loop which will cause it to move forward for five seconds and then turn 90 degrees to the left. This loops indefinitely, so the robot will continue to drive in a square-like fashion. This will also print out the time to the console every time the robot starts moving or turning.

![Drive Square](/drive_square.gif)

## Person Follower
### Description 
This node will cause the robot orient itself towards the nearest object ('person') and move towards it. The object may be moved around and the robot will automatically adjust. It will stop about 0.2m in front of the object.

### Code Explanation
* `PersonFollower`: The pythonic object that is responsible for the **person_follower** behavior.
    * `PersonFollower.__init__()`: constructor for a `PersonFollower`. In addition to creating the object, this function initializes the ROS node, a `Twist` message for the node to use, the `Twist` publisher, a `LaserScan` subscriber, and several constants necessary for proportional control. 
    * `PersonFollower.follow_person()`: This is the meat of the robot. Here, the code loops through the `ranges` array in the `LaserScan` message and finds the distance and index of the closest object. It then uses these values to orient the robot and move it forward. The index is "rotated" by 180 degrees such that anything in the range of 150 to 210 degrees can be considered "in front" of the robot. If the index is within this range, the robot moves forward at a speed proportional to its distance (faster if further away). Otherwise, the robot moves forward at a constant speed. In either case, the robot adjusts it's angular velocity based on how far the index is from 180. Because of proportional control, the robot will also automatically stop when it is close (0.2m) to the object.
    * `PersonFollower.run()`: This is just a wrapper call to `rospy.spin()` to keep the robot busy.

![Person Follower](/person_follower.gif)

## Wall Follower
Still in the works...

## Challenges
For **drive_square**, one of the hardest parts was cleaning up the noise. If the velocity was too great, the noise artificially generated by Gazebo Simulator would throw the robot hopelessly off course. This was overcome by using a slower velocity (and thus a smaller noise). However, it should still be noted that the robot does not drive in a perfect square. After 3-4 iterations, it will no longer be on target. 

## Future Work
For **drive_square**, I would like to have the robot be able to drive faster and still be able to fend off the noise. I think this could be accomplished by gradually accelerating/decelerating when moving/stopping along a straight line, but I did not have a chance to test.

## Takeaways
* *Object Orientated code is very clean*. Although it requires a bit more thought and planning on the front-end, keeping OOP in mind makes your code really clean overall. Each subgoal/problem should be met with a single instance of an object. This object should have all the necessary methods and tools to solve this subtask. Although this project was short, I imagine this would be very handy for lengthier projects.
* *Noise is a major problem*. For any movement-based robot, this is going to be one of the main problems that needs solving. The noise completely throws off any robot moving/turning relatively fast. As such, the robot should be designed to be able to overcome significant amounts of noise, especially if it also needs to move quickly. 
